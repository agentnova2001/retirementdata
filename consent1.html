<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body { margin:0; font-family:sans-serif; display:flex; justify-content:center; background:#f5f5f5; }
  .wrapper { width:100%; max-width:420px; padding:12px; }
  .pad-container { position:relative; width:100%; height:120px; border:1px solid #ccc; background:white; touch-action:none; }
  canvas { position:absolute; inset:0; width:100%; height:100%; cursor:crosshair; }
  .buttons { display:flex; gap:8px; margin-top:10px; }
  button { flex:1; padding:15px 0; font-size:14px; border-radius:6px; border:none; cursor:pointer; font-weight:bold; }
  .submit { background:#4a6cf7; color:white; }
  .reset { background:#ddd; }
</style>
</head>
<body>
<div class="wrapper">
  <div class="pad-container" id="pad"><canvas id="canvas"></canvas></div>
  <div class="buttons">
    <button class="reset" onclick="resetPad()">다시하기</button>
    <button class="submit" onclick="submitPad()">제출</button>
  </div>
</div>

<script>
const pad = document.getElementById("pad");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
let drawing = false; let hasDrawn = false;

function resize() {
  canvas.width = pad.clientWidth;
  canvas.height = pad.clientHeight;
  drawBackground();
}
window.addEventListener("resize", resize);
resize();

function drawBackground() {
  const w = canvas.width; const h = canvas.height;
  ctx.fillStyle = "#cfeeff"; ctx.fillRect(0,0,w/2,h);
  ctx.fillStyle = "#ffffff"; ctx.fillRect(w/2,0,w/2,h);
  ctx.strokeStyle="#bbb"; ctx.setLineDash([5, 5]);
  ctx.beginPath(); ctx.moveTo(w/2,0); ctx.lineTo(w/2,h); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle="#000"; ctx.font="bold 14px sans-serif"; ctx.textAlign="center";
  ctx.fillText("동의", w/4, h/2 + 5); ctx.fillText("미동의", (w*3)/4, h/2 + 5);
}

function getPos(e) {
  const r = canvas.getBoundingClientRect();
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;
  return { x: clientX - r.left, y: clientY - r.top };
}

function start(e) { drawing = true; hasDrawn = true; ctx.beginPath(); const {x,y} = getPos(e); ctx.moveTo(x,y); }
function move(e) { if(!drawing) return; const {x,y} = getPos(e); ctx.strokeStyle = "#222"; ctx.lineWidth = 3; ctx.lineTo(x,y); ctx.stroke(); }
function stop() { drawing = false; }

canvas.addEventListener("mousedown", start);
canvas.addEventListener("mousemove", move);
window.addEventListener("mouseup", stop);
canvas.addEventListener("touchstart", (e) => { e.preventDefault(); start(e); });
canvas.addEventListener("touchmove", (e) => { e.preventDefault(); move(e); });
canvas.addEventListener("touchend", stop);

function resetPad() { ctx.clearRect(0,0,canvas.width,canvas.height); drawBackground(); hasDrawn = false; }

function submitPad() {
  if(!hasDrawn) { alert("서명 영역에 표시를 해주세요."); return; }
  
  // 캔버스 마지막 터치 지점이나 중앙값 기준으로 간단히 판별 (여기서는 테스트용 AGREE 고정)
  const finalFlag = "AGREE"; 

  // ✅ [Typebot 핵심 연동] 
  // 루프 방식이므로 부모 창에 변수만 정확히 던지면 됩니다.
  if (window.parent) {
    window.parent.postMessage({
      type: 'setVariables',
      variables: { "consent1_flag": finalFlag }
    }, "*");
    
    // 사용자 경험을 위해 버튼 비활성화 및 안내
    const btn = document.querySelector('.submit');
    btn.innerText = "전송됨";
    btn.style.background = "#28a745";
    btn.disabled = true;
  }
}
</script>
</body>
</html>
